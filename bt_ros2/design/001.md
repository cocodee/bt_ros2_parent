好的，我们来创建一个完整的、解耦的 `behavior_tree_node` 项目。这个项目将包含一个行为树节点，它通过 ROS 2 Action 接收指令，然后执行一个非常简单的行为树——打印收到的指令并返回成功。

这个项目将遵循最佳实践，结构清晰，并包含所有必要的代码和文档。

---

### 1. 项目结构

我们将创建一个名为 `bt_ros2` 的 ROS 2 包，其结构如下：

```
bt_ros2/
├── bt_trees/
│   └── print_command_tree.xml   # 行为树定义文件
├── include/bt_ros2/
│   ├── behavior_tree_node.hpp   # 行为树节点头文件
│   └── print_command_action.hpp # 自定义BT节点头文件
├── src/
│   ├── behavior_tree_node.cpp   # 行为树节点实现
│   ├── print_command_action.cpp # 自定义BT节点实现
│   └── bt_executor.cpp          # 主程序入口
├── package.xml
└── CMakeLists.txt
```
*我们还将依赖一个自定义的 Action 接口，假设它在另一个名为 `my_robot_interfaces` 的包中。*

---

### 2. `my_robot_interfaces` 包 (依赖)

首先，你需要一个包来定义 Action 接口。

#### `my_robot_interfaces/action/ExecuteCommand.action`
```action
# Goal definition
string command
---
# Result definition
bool success
---
# Feedback definition
string status
```

确保这个包已经被编译 (`colcon build --packages-select my_robot_interfaces`)。

---

### 3. `bt_ros2` 包 - 详细代码与文档

#### `package.xml`

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>bt_ros2</name>
  <version>0.1.0</version>
  <description>A demo package for integrating BehaviorTree.CPP with ROS 2.</description>
  <maintainer email="user@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>rclcpp_action</depend>
  <depend>behaviortree_cpp</depend>
  <depend>my_robot_interfaces</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

#### `CMakeLists.txt`
```cmake
cmake_minimum_required(VERSION 3.8)
project(bt_ros2)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(rclcpp_action REQUIRED)
find_package(behaviortree_cpp REQUIRED)
find_package(my_robot_interfaces REQUIRED)

# Include directories
include_directories(include)

# Custom Action Node: PrintCommand
add_library(print_command_action
  src/print_command_action.cpp
)
target_include_directories(print_command_action PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>
)
ament_target_dependencies(print_command_action
  behaviortree_cpp
  rclcpp
)

# Behavior Tree Node Class
add_library(behavior_tree_node_lib
  src/behavior_tree_node.cpp
)
target_include_directories(behavior_tree_node_lib PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>
)
ament_target_dependencies(behavior_tree_node_lib
  rclcpp
  rclcpp_action
  behaviortree_cpp
  my_robot_interfaces
)
target_link_libraries(behavior_tree_node_lib
  print_command_action
)

# Main Executable
add_executable(bt_executor src/bt_executor.cpp)
ament_target_dependencies(bt_executor rclcpp)
target_link_libraries(bt_executor behavior_tree_node_lib)

# Install rules
install(
  DIRECTORY include/
  DESTINATION include
)
install(
  DIRECTORY bt_trees
  DESTINATION share/${PROJECT_NAME}/
)
install(
  TARGETS
  print_command_action
  behavior_tree_node_lib
  bt_executor
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

---

### 4. 源代码

#### `bt_trees/print_command_tree.xml`
这是一个非常简单的行为树。它只有一个动作节点 `PrintCommand`。
```xml
<root main_tree_to_execute="MainTree">
    <BehaviorTree ID="MainTree">
        <Sequence>
            <!-- 
              The 'received_command' will be written to the blackboard
              by the ROS 2 Action Server when a new goal is accepted.
            -->
            <PrintCommand message="{received_command}"/>
        </Sequence>
    </BehaviorTree>
</root>
```

#### `include/bt_ros2/print_command_action.hpp`
这是自定义行为节点的头文件。
```hpp
#ifndef PRINT_COMMAND_ACTION_HPP_
#define PRINT_COMMAND_ACTION_HPP_

#include "behaviortree_cpp/basic_types.h"
#include "behaviortree_cpp/tree_node.h"
#include "rclcpp/rclcpp.hpp"

// Simple synchronous action that prints a message from its input port.
class PrintCommand : public BT::SyncActionNode
{
public:
  // The constructor expects a node name and the configuration.
  PrintCommand(const std::string& name, const BT::NodeConfiguration& config)
    : BT::SyncActionNode(name, config)
  {}

  // Define the input ports required by this node.
  static BT::PortsList providedPorts()
  {
    // This node has a single input port called "message"
    return { BT::InputPort<std::string>("message") };
  }

  // This is the method that is executed by the tree.
  BT::NodeStatus tick() override
  {
    // Retrieve the message from the input port.
    auto res = getInput<std::string>("message");
    if (!res) {
      // If the input port is not set, throw an error.
      throw BT::RuntimeError("missing required input [message]: ", res.error());
    }

    // Print the message to the console.
    // In a real ROS 2 node, you should use RCLCPP_INFO.
    // Here we use std::cout for simplicity.
    std::cout << "[PrintCommand]: " << res.value() << std::endl;
    
    // The action is always successful.
    return BT::NodeStatus::SUCCESS;
  }
};

#endif // PRINT_COMMAND_ACTION_HPP_
```

#### `src/print_command_action.cpp`
这个自定义节点的实现文件（在这个简单的例子中，所有实现都在头文件里，所以这个文件可以是空的，但为了项目结构完整性而保留）。
```cpp
#include "bt_ros2/print_command_action.hpp"

// All implementation is in the header for this simple node.
```

#### `include/bt_ros2/behavior_tree_node.hpp`
这是核心的、解耦的行为树节点类的头文件。
```hpp
#ifndef BEHAVIOR_TREE_NODE_HPP_
#define BEHAVIOR_TREE_NODE_HPP_

#include <string>
#include <memory>
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "behaviortree_cpp/bt_factory.h"
#include "behaviortree_cpp/loggers/bt_cout_logger.h"
#include "ament_index_cpp/get_package_share_directory.hpp"

#include "my_robot_interfaces/action/execute_command.hpp"
#include "bt_ros2/print_command_action.hpp"

namespace bt_ros2
{

class BehaviorTreeNode : public rclcpp::Node
{
public:
  explicit BehaviorTreeNode(const rclcpp::NodeOptions & options);

private:
  using ExecuteCommand = my_robot_interfaces::action::ExecuteCommand;
  using GoalHandleExecuteCommand = rclcpp_action::ServerGoalHandle<ExecuteCommand>;

  // Action Server callbacks
  rclcpp_action::GoalResponse handle_goal(
    const rclcpp_action::GoalUUID & uuid,
    std::shared_ptr<const ExecuteCommand::Goal> goal);

  rclcpp_action::CancelResponse handle_cancel(
    const std::shared_ptr<GoalHandleExecuteCommand> goal_handle);

  void handle_accepted(
    const std::shared_ptr<GoalHandleExecuteCommand> goal_handle);

  // Behavior Tree main loop
  void tick_tree();

  BT::BehaviorTreeFactory factory_;
  BT::Tree tree_;
  BT::Blackboard::Ptr blackboard_;
  std::unique_ptr<BT::StdCoutLogger> bt_logger_;

  rclcpp_action::Server<ExecuteCommand>::SharedPtr action_server_;
  rclcpp::TimerBase::SharedPtr timer_;
  std::shared_ptr<GoalHandleExecuteCommand> current_goal_handle_;
};

} // namespace bt_ros2

#endif // BEHAVIOR_TREE_NODE_HPP_
```

#### `src/behavior_tree_node.cpp`
这是核心节点的实现。
```cpp
#include "bt_ros2/behavior_tree_node.hpp"

namespace bt_ros2
{

BehaviorTreeNode::BehaviorTreeNode(const rclcpp::NodeOptions & options)
  : Node("behavior_tree_node", options)
{
  // --- Behavior Tree Setup ---
  RCLCPP_INFO(this->get_logger(), "Setting up Behavior Tree...");

  // Register our custom node into the factory
  factory_.registerNodeType<PrintCommand>("PrintCommand");

  // Create the blackboard
  blackboard_ = BT::Blackboard::create();

  // Find the path to the XML file
  std::string package_share_directory = ament_index_cpp::get_package_share_directory("bt_ros2");
  std::string xml_file = package_share_directory + "/bt_trees/print_command_tree.xml";

  // Create the tree. The blackboard is shared with the tree.
  tree_ = factory_.createTreeFromFile(xml_file, blackboard_);
  
  // Add a logger to print transitions on the console
  bt_logger_ = std::make_unique<BT::StdCoutLogger>(tree_);

  // --- ROS 2 Action Server Setup ---
  RCLCPP_INFO(this->get_logger(), "Setting up Action Server...");
  this->action_server_ = rclcpp_action::create_server<ExecuteCommand>(
    this,
    "execute_command",
    std::bind(&BehaviorTreeNode::handle_goal, this, std::placeholders::_1, std::placeholders::_2),
    std::bind(&BehaviorTreeNode::handle_cancel, this, std::placeholders::_1),
    std::bind(&BehaviorTreeNode::handle_accepted, this, std::placeholders::_1)
  );
  
  // --- Main Loop Timer ---
  timer_ = this->create_wall_timer(
    std::chrono::milliseconds(200), // Tick at 5 Hz
    std::bind(&BehaviorTreeNode::tick_tree, this)
  );
  RCLCPP_INFO(this->get_logger(), "Node initialized. Ready to receive commands.");
}

rclcpp_action::GoalResponse BehaviorTreeNode::handle_goal(
  const rclcpp_action::GoalUUID &,
  std::shared_ptr<const ExecuteCommand::Goal> goal)
{
  RCLCPP_INFO(this->get_logger(), "Received goal request with command: %s", goal->command.c_str());
  // Always accept new goals
  return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
}

rclcpp_action::CancelResponse BehaviorTreeNode::handle_cancel(
  const std::shared_ptr<GoalHandleExecuteCommand> goal_handle)
{
  RCLCPP_INFO(this->get_logger(), "Received request to cancel goal");
  // Always accept cancel requests
  return rclcpp_action::CancelResponse::ACCEPT;
}

void BehaviorTreeNode::handle_accepted(
  const std::shared_ptr<GoalHandleExecuteCommand> goal_handle)
{
  // This is where we link the action goal to the behavior tree
  RCLCPP_INFO(this->get_logger(), "Goal accepted. Writing command to blackboard.");
  
  // Store the goal handle
  current_goal_handle_ = goal_handle;

  // Halt any previously running tree to start fresh
  tree_.haltTree();

  // Write the command from the goal to the blackboard
  blackboard_->set("received_command", goal_handle->get_goal()->command);
}

void BehaviorTreeNode::tick_tree()
{
  if (!current_goal_handle_) {
    // No active goal, do nothing.
    return;
  }

  // Tick the tree and get the status
  BT::NodeStatus status = tree_.tickRoot();

  // Check the status to decide the action result
  if (status == BT::NodeStatus::SUCCESS) {
    auto result = std::make_shared<ExecuteCommand::Result>();
    result->success = true;
    current_goal_handle_->succeed(result);
    current_goal_handle_.reset(); // Clear the handle
    RCLCPP_INFO(this->get_logger(), "Behavior Tree executed successfully.");
  } else if (status == BT::NodeStatus::FAILURE) {
    auto result = std::make_shared<ExecuteCommand::Result>();
    result->success = false;
    current_goal_handle_->abort(result);
    current_goal_handle_.reset();
    RCLCPP_INFO(this->get_logger(), "Behavior Tree execution failed.");
  }
  // If status is RUNNING, do nothing and wait for the next tick.
}

} // namespace bt_ros2
```

#### `src/bt_executor.cpp`
这是主程序，它只负责初始化 ROS 并启动节点。
```cpp
#include "rclcpp/rclcpp.hpp"
#include "bt_ros2/behavior_tree_node.hpp"

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);

  rclcpp::NodeOptions options;
  auto node = std::make_shared<bt_ros2::BehaviorTreeNode>(options);

  rclcpp::spin(node);

  rclcpp::shutdown();
  return 0;
}
```

---

### 5. 如何编译和运行

1.  **编译**:
    ```bash
    cd /path/to/your/ros2_ws
    # First, build the interface package
    colcon build --packages-select my_robot_interfaces
    # Then, build the demo package
    colcon build --packages-select bt_ros2
    ```

2.  **运行**:
    *   打开一个新终端，并 source 你的工作空间：
        ```bash
        source install/setup.bash
        ```
    *   启动行为树节点：
        ```bash
        ros2 run bt_ros2 bt_executor
        ```
        你应该能看到日志 "Node initialized. Ready to receive commands."

3.  **测试**:
    *   打开第二个终端，并 source 你的工作空间。
    *   使用 ROS 2 命令行工具发送一个 Action goal：
        ```bash
        ros2 action send_goal /execute_command my_robot_interfaces/action/ExecuteCommand "{command: 'Hello Behavior Tree!'}"
        ```

### 预期输出

**在 `bt_executor` 终端中，你应该看到：**

```
[INFO] [167...]: Setting up Behavior Tree...
[INFO] [167...]: Setting up Action Server...
[INFO] [167...]: Node initialized. Ready to receive commands.
[INFO] [167...]: Received goal request with command: Hello Behavior Tree!
[INFO] [167...]: Goal accepted. Writing command to blackboard.
[BT]: Tree is ticking
   [SUCCESS] -> Sequence
     [SUCCESS] -> PrintCommand
[PrintCommand]: Hello Behavior Tree!
[INFO] [167...]: Behavior Tree executed successfully.
```

**在发送指令的终端中，你应该看到：**

```
Waiting for action server...
Sending goal:
{
    "command": "Hello Behavior Tree!"
}
Goal accepted with ID: ...
Result:
{
    "success": true
}
```

这个完整的项目展示了如何以一种解耦、可维护的方式将 BehaviorTree.CPP 与 ROS 2 集成，即使对于最简单的任务，遵循这种良好的架构也能带来巨大的好处。